<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dynamic Web Plot</title>
		<meta charset="utf-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

		<!-- Bootstrap -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
		<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

		<script src=https://cdnjs.cloudflare.com/ajax/libs/mathjs/3.3.0/math.min.js></script>

		<style>
			body, html {
				height: 100%;
				margin: 0px;
			}
			
			.code-tab {
				border-color: #dee2e6 #dee2e6 #fff !important;
			}

			.code-tab.active {
				border: 1px solid transparent !important;
			}

			.console-output {
				white-space: pre-wrap;
			}

			.flexColumn {
				display: flex;
				flex-flow: column;
			}

			.strechHeight {
				height: 100%;	
			}
			
			#graph {
				background-color: white;
			}

			.editor { 
		        position: relative;
		        width: 100%;
		        height: 100%;
		    }

			.btn-circle { 
	            width: 30px; 
	            height: 30px;
	            padding: 0px;
	            border-radius: 15px; 
	            font-size: 14px; 
	            text-align: center; 
	        } 

		</style>
	</head>
	<body>
		<div id="content" class="container-fluid flexColumn strechHeight">
				<div class="nav nav-tabs" role="tablist" style="padding-top: 5px;">
					<a class="nav-item nav-link active" id="nav-user-tab" data-toggle="tab" href="#nav-user" role="tab" aria-controls="nav-user" aria-selected="true" onclick="DyPlot_Private.__switchToUser__();">User</a>
					<a class="nav-item nav-link" id="nav-dev-tab" data-toggle="tab" href="#nav-dev" role="tab" aria-controls="nav-dev" aria-selected="false" onclick="DyPlot_Private.__switchToDeveloper__();">Developer</a>
					<label class="btn btn-success" style="margin-left: 10px; margin-right: 5px;" onclick="DyPlot_Private.__save__();">
					    Save Plot
					</label>
					<label class="btn btn-secondary">
					    Open Plot <input type="file" id="file-open-form" hidden>
					</label>
				</div>
			<div class="tab-content flexColumn flex-grow-1">
				
				<div class="tab-pane fade show active flex-grow-1" id="nav-user" role="tabpanel" aria-labelledby="nav-user-tab">
					<div class="flexColumn" style="height: 100%">
						<div id="graphHeading" class="row no-gutters">
			  				<div class="col-3">

			  					<!-- <input type="email" class="form-control" id="title_input"> -->
			  					<!-- <h3 class="display-4 text-center" onclick="console.log('test');">Untitled</h3> -->
			  				</div>
							<div class="col-9">
								<div class="float-right" style="margin: 10px 0 0 0">
						 			<button type="button" class="btn btn-outline-primary btn-circle" style="margin: 0px 6px;" onclick="DyPlot_Private.__zoomOut__();">-</button>
									<button type="button" class="btn btn-outline-primary" onclick="DyPlot_Private.__zoomHome__();">Home</button>
									<button type="button" class="btn btn-outline-primary btn-circle" style="margin: 0px 6px;" onclick="DyPlot_Private.__zoomIn__();">+</button>
								</div>
				  			</div>
				  		</div>
					  	<canvas id="graph" class="flex-grow-1"></canvas>
				  	</div>
	  			</div>
				<div class="tab-pane fade flex-grow-1" id="nav-dev" role="tabpanel" aria-labelledby="nav-dev-tab">
					<div class="flexColumn" style="height: 100%">
						<ul class="nav nav-tabs" role="tablist">
							<li class="nav-item" role="presentation">
								<a class="nav-link active text-white bg-dark code-tab" id="setup-tab" data-toggle="tab" href="#setup-tab-content" role="tab" aria-controls="setup-tab-content" aria-selected="true">setup.js</a>
								</li>
							<li class="nav-item" role="presentation">
								<a class="nav-link text-white bg-dark code-tab" id="update-tab" data-toggle="tab" href="#update-tab-content" role="tab" aria-controls="update-tab-content" aria-selected="false">update.js</a>
							</li>
						</ul>
						<div class="flexColumn flex-grow-1">
							<div class="tab-content flexColumn flex-grow-1">
								<div class="tab-pane fade show active flex-grow-1" id="setup-tab-content" role="tabpanel" aria-labelledby="setup-tab">
									<div class="editor" id="setup-editor">var figure = new dyplot.Figure();
figure.plotAxis(5);
let args = {link: "joe", showLines:true, pointColor: "purple",
                lineColor: "red", lineDash:[1, 2, 3]};
figure.plotXY([1, 0], [0, 2], args);
figure.plotText("Mirror", 1, 1);</div>
								</div>
								<div class="tab-pane fade flex-grow-1" id="update-tab-content" role="tabpanel" aria-labelledby="update-tab">
									<div class="editor" id="update-editor">dyplot.Console.clear();

let arrays = dyplot.Controls.get("joe");
dyplot.Console.print(arrays);

let args = {pointColor: "blue", showLines: true};
figure.plotXY(arrays[1], arrays[0], args);</div>
								</div>
							</div>
							<div class="card" style="height: 250px;">
								<div class="card-body flexColumn" style="height: 100%;">
									<div class="border-bottom" style="padding-bottom: 5px;">
										<span style="display: inline-block;">
											<h5 class="card-title">Console</h5>
										</span>
										<button type="button" class="btn btn-success" style="float: right;" onclick="DyPlot_Private.__alert__('Dynamic Web Plot', 'Started Test Run');DyPlot_Private.__onSetup__();">Test Run</button>
										<button type="button" class="btn btn-secondary" style="float: right; margin-right: 5px;" onclick="DyPlot_Private.__alert__('Dynamic Web Plot', 'Console is cleared'); dyplot.Console.clear();">Clear Console</button>
										<button type="button" class="btn text-white bg-danger" style="float: right; margin-right: 5px;" onclick="
				DyPlot_Private.__alert__('Dynamic Web Plot', 'All Controls are resetted'); DyPlot_Private.Control.__resetControls();">Reset Controls</button>	
									</div>
									<div class="flexColumn flex-grow-1" style="overflow: hidden;">
										<ul id="console" class="list-group list-group-flush flex-grow-1" style="overflow-y: auto;">
										</ul>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
	  		</div>
  		</div>
  		<div style="position: fixed; top: 0; right: 0;">
			<div aria-live="polite" aria-atomic="true" style="min-height: 200px;">
				<div class="toast bg-light" style="position: absolute; top: 0; right: 0; width: 0px; margin: 10px;">
					<div class="toast-header text-white bg-info">
						<strong class="mr-auto" id="alert_title"></strong>
						<small id="alert_time">1 sec ago</small>
						<button type="button" class="ml-2 mb-1 close" data-dismiss="toast" aria-label="Close">
							<span aria-hidden="true">&times;</span>
						</button>
					</div>
					<div id="alert_body" class="toast-body">
					</div>
				</div>
			</div>
		</div>
	</body>
	<script src="https://pagecdn.io/lib/ace/1.4.5/ace.js" integrity="sha256-5Xkhn3k/1rbXB+Q/DX/2RuAtaB4dRRyQvMs83prFjpM=" crossorigin="anonymous"></script>
	
	<script type="text/javascript">
		// Configure Script

		// TODO :
		// Add animation feature & argument
		// Add plotting web images
		// Add controls menu
		// Allow "mouse scroll" to control zoom 
		// Make element borders draggable
		// Fix timing on Boostrap Toasts for alerts
		// Possibly integrate with quacc (simulations can be dynamic web plots)
		// Add Google drive integration (to allow sharable plots as just links)
		// Follow console output
		// Add droppable save file

		var dyplot = {};
		var DyPlot_Private = {};

		(function(dyplot, DyPlot_Private, $, undefined) {
			class __Utils__ {
				static isIterable(obj) {
	  				// checks for null and undefined
					if (obj == null) {
						return false;
					}
					return typeof obj[Symbol.iterator] === 'function';
				}
				static sleep(time) {
					return new Promise((resolve, reject) => setTimeout(resolve, time));
				}
			}


			class LinkedList {
				constructor (elements=[]) {
					this._startNode = null;
					this._size = 0;
					this._forward = true;
					for (let elem of elements)
						this.add(elem);
				}

				_link(firstNode, secondNode) {
					firstNode._next = secondNode;
					secondNode._prev = firstNode;
				}

				_prune(node) {
					node._prev = null;
					node._next = null;
					return node._element;
				}

				addFirst(elem) {
					let node = LinkedList._createNode(elem);
					if (this._startNode === null) {
						this._link(node, node);
					} else if (this._forward) {
						this._link(this._startNode._prev, node);
						this._link(node, this._startNode);
					} else {
						this._link(node, this._startNode._next);
						this._link(this._startNode, node);
					}
					this._startNode = node;
					this._size ++;
				}



				removeFirst () {
					if (this._startNode === null) 
						return null;
					let elem = null;
					if (this._size === 1) {
						elem = this._prune(this._startNode);
						this._startNode = null;
					} else {
						let prevNode = this._startNode._prev;
						let nextNode = this._startNode._next;
						elem = this._prune(this._startNode);
						this._link(prevNode, nextNode);
						if (this._forward)
							this._startNode = nextNode;
						else
							this._startNode = prevNode;
					}
					this._size -- ;
					return elem;
				}

				_spinDir (index) {
					let size = this._size;
					if (!this._forward)
						index = -index;
					let actual = ((index % size) + size) % size;
					let forward = actual < size / 2; 
					let amount;
					if (forward)
						amount = actual;
					else
						amount = size - actual;

					return [forward, amount];
				}

				spin(index) {
					let size = this._size;
					if (size === 0)
						return 0;
					const [forward, amount] = this._spinDir(index);
					let currentNode = this._startNode;
					if (forward)
						for (let i of range(amount))
							currentNode = currentNode._next;
					else
						for (let i of range(amount))
							currentNode = currentNode._prev;
					this._startNode = currentNode;
					return amount != 0;
				}

				flip() {
					this._forward = !this._forward;
					this.spin(1);
				}

				addLast(elem) { 
					this.flip();
					this.addFirst(elem);
					this.flip();
				}


				removeLast() { 
					this.flip();
					let elem = this.removeFirst();
					this.flip();
					return elem;
				}


				push(elem) {
					this.addFirst(elem);
				}

				pop() { 
					return this.removeFirst();
				}

				enqueue(elem) { 
					this.addFirst(elem);
				}

				dequeue() {
					return this.removeLast();
				}


				add(elem, index=null) {
					if (index === null)
						index = this._size;

					let nextSize = this._size + 1;
					index = ((index % nextSize) + nextSize) % (nextSize);

					let startNode = this._startNode;
					if (index !== this._size)
						this.spin(index);

					this.addFirst(elem);
					if (startNode != null) 
						this._startNode = startNode;
				}


				remove(index=null) {
					if (index == null)
						index = -1;
					let startNode = this._startNode;
					let moved = this.spin(index);
					let elem = this.removeFirst();
					if (moved)
						this._startNode = startNode;
					return elem;
				}


				clear() {
					if (this._startNode != null)
						this._prune(this._startNode);
					this._startNode = null;
					this._size = 0;
				}

				contains(value) {
					for (let elem of this)   /// do this
						if (elem === value)
							return true;
					return false;
				}

				set(index, elem) {
					let startNode = this._startNode;
					this.spin(index);
					this._startNode._element = elem;
					this._startNode = startNode;
				}


				get(index) {
					let startNode = this._startNode;
					this.spin(index);
					let elem = this._startNode._element;
					this._startNode = startNode;
					return elem;
				}

				get length() { 
					return this._size;
				}

				toString() { 
					let _str = '(' + this._size + ')[';
					let last = this.remove();

					for (let elem of this) {
						_str = _str + String(elem) + ', ';
					}
					if (last !== null) {
						_str = _str + String(last);
						this.add(last);
					}
					return _str + ']';
				}

				[Symbol.iterator]() {
					let curIndex = this._size;
					let node = this._startNode;
					let direction = this._forward;
					return {
						next() {
							if (curIndex <= 0)
								return {done : true};
							curIndex --;
							let elem = null;

							if (node !== null) {
								elem = node._element;
								if (direction)
									node = node._next;
								else
									node = node._prev;
							}
							return {done : false, value : elem};
						}
					};
				}

				static _createNode(value, previous=null, next=null) {
					return {
						_element : value,
						_prev : previous,
						_next : next,
					}
				}

			}
			Object.freeze(LinkedList);
			dyplot.LinkedList = LinkedList;



			class Matrix {
				static spread(arr) {
					if (arr.length != 1)
						return arr;
					if (arr[0] instanceof Array)
						return arr[0];
					else
						return arr;
				}

				constructor(rows=-1, columns=-1, ...elements) {

					elements = Matrix.spread(elements);
					if (elements.length === 0) {
						if (rows === -1) {
							if (columns === -1)
								throw "Must Specify Dimensions";
							rows = 1;
						} else if (columns === -1) {
							columns = 1;
						}
						elements = new Array(rows * columns).fill(0);
					} else {
						if (columns === -1) {
							if (rows === -1) {
								rows = elements.length;
								columns = 1;
							} else {
								columns = Math.round(elements.length / rows); 
							}
						} else if (rows === -1) {
							rows = Math.round(elements.length / columns);
						}
					}
					this._elements = elements;
					this.rows = rows;
					this.columns = columns;
				}

				get(row, column) {
					return this._elements[row * this.columns + column];
				}

				set(element, row, column) {
					this._elements[row * this.columns + column] = element;
				}

				bulkGet(row, column) {
					if (__Utils__.isIterable(row) || __Utils__.isIterable(column)) {
						let rows = null;
						let columns = null;
						if (! __Utils__.isIterable(row)) {
							rows = [row];
							if (! Arrays.isArray(column))
								columns = new LinkedList(column);
						} else if (! __Utils__.isIterable(column)) {
							if (! Arrays.isArray(rows))
								rows = new LinkedList(row);
							columns = [column];
						}

						let output = new Array(rows.length);
						let r = 0;
						for (let row of rows) {
							let columnArray = new Array(columns.length);
							let c = 0;
							for (let column of columns)
								columnArray[c++] = this.get(row, column);
							output[r++] = columnArray;
						}
						return output;
					} else {
						return this.get(row, column);
					}
				}

				bulkSet(row, column) {
					if (__Utils__.isIterable(row) || __Utils__.isIterable(column)) {
						let rows = null;
						let columns = null;
						if (! __Utils__.isIterable(row)) {
							rows = [row];
							if (! Arrays.isArray(columns))
								columns = new LinkedList(column);
						} else if (! __Utils__.isIterable(column)) {
							if (! Arrays.isArray(rows))
								rows = new LinkedList(row);
							columns = [column];
						}
						
						if (! __Utils__.isIterable(element)) {
							for (let row of rows)
								for (let column of columns)
									this.set(element, row, column);
							return output;
						} else {
							let elems = new LinkedList(element);
							if (__Utils__.isIterable(elems.get(0))) {
								for (let row of rows) {
									let colElems = new LinkedList(elems.get(0));
									for (let column of columns) {
										this.set(colElems.get(0), row, column);
										colElems.spin(1);
									}
									elems.spin(1);
								}
							} else {
								for (let row of rows) {
									for (let column of columns) {
										this.set(elems.get(0), row, column);
										elems.spin(1);
									}
								}	
							}
						}
					} else {
						this.set(row, column);
					}
				}

				subMat(rows, columns) {
					return matrix(this.bulkGet(rows, columns));
				}



				add(...values) {
					values = Matrix.spread(values);
					let shift = 0;
					let currentMatrix = this;
					for (let value of values)
						if (typeof value === "number")
							shift += value;
						else
							currentMatrix = currentMatrix._add(value);
					if (shift !== 0)
						currentMatrix = currentMatrix._shift(shift);
					return currentMatrix;
				}

				mult(elem=false, ...values) {
					values = Matrix.spread(values);
					if (elem)
						return this.multiply(values);
					else
						return this.matmul(values);
				}

				matmul(...values) {
					values = Matrix.spread(values);
					let scale = 1;
					let currentMatrix = this;
					for (let value of values)
						if (typeof value === "number")
							scale *= value;
						else
							currentMatrix = currentMatrix._matmul(value);
					if (scale !== 1)
						currentMatrix = currentMatrix._scale(scale);
					return currentMatrix;
				}

				multiply(...values) {
					values = Matrix.spread(values);
					let scale = 1;
					let currentMatrix = this;
					for (let value of values)
						if (typeof value === "number")
							scale *= value;
						else
							currentMatrix = currentMatrix._multiply(value);
					if (scale !== 1)
						currentMatrix = currentMatrix._scale(scale);
					return currentMatrix;
				}

				_shift(value) {
					let newMatrix = new Matrix(this.rows, this.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c)+value, r, c);
					return newMatrix;
				}

				_add(matrix) {
					let newMatrix = new Matrix(this.rows, this.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c)+matrix.get(r, c), r, c);
					return newMatrix;
				}


				_scale(value) {
					let newMatrix = new Matrix(this.rows, this.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c)*value, r, c);
					return newMatrix;
				}

				_mult(matrix, elem=false) {
					if (elem)
						return this._multiply(matrix);
					else
						return this._matmul(matrix);
				}

				_multiply(matrix) {
					let newMatrix = new Matrix(this.rows, this.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c)*matrix.get(r, c), r, c);
					return newMatrix;
				}

				_matmul(matrix) {
					let newMatrix = new Matrix(this.rows, matrix.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < matrix.columns; c++){
							let sum = 0;
							for (let k = 0; k < this.columns; k++)
								sum += this.get(r, k) * matrix.get(k, c);
							newMatrix.set(sum, r, c);
						}
					return newMatrix;
				}

				toString() {
					let colStrSize = new Array(this.columns);
					for (let c = 0 ; c < this.columns; c ++) {
						let largestSize = 1;
						for (let r = 0 ; r < this.rows; r ++) {
							let str = this.get(r, c).toString();
							let currentSize = str.length;
							if (currentSize > largestSize)
								largestSize = currentSize;
						}
						colStrSize[c] = largestSize;
					}
					let finalStr = "";
					for (let r = 0; r < this.rows; r ++) {
						finalStr += "| "
						for (let c = 0; c < this.columns; c ++) {
							let str = this.get(r, c).toString();
							for (let i = str.length; i < colStrSize[c]; i++)
								finalStr += " ";
							finalStr += str + " ";
						}
						finalStr += "|\n";
					}
					return finalStr;
				}

				get size() {
					return this._elements.length;
				}

				get t() {
					let newMatrix = new Matrix(this.columns, this.rows);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c), c, r);
					return newMatrix;
				}

				get h() {
					let newMatrix = new Matrix(this.rows + 1, this.columns + 1);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c), r, c);
					newMatrix.set(1, this.rows, this.columns);
					return newMatrix;
				}

				get hv() {
					let newMatrix = new Matrix(this.rows + 1, this.columns);
					for (let r = 0; r < this.rows; r++)
						for (let c = 0; c < this.columns; c++)
							newMatrix.set(this.get(r, c), r, c);
					for (let c = 0; c < this.columns; c++)
						newMatrix.set(1, this.rows, c);
					return newMatrix;
				}
			}
			Object.freeze(Matrix);
			dyplot.Matrix = Matrix;



			function* range(arg1, arg2=null, delta=1) {
				let start;
				let end;
				if (arg2 === null) {
					start = 0;
					end	  = arg1;
				} else {
					start = arg1;
					end = arg2;
				}
				for (let i = start; i < end; i += delta)
					yield i;
			}
			Object.freeze(range);
			dyplot.range = range;




			function matrix  (doubleArray) {
				if (doubleArray instanceof Matrix)
					return doubleArray;
				let rows = doubleArray.length;
				let columns = doubleArray[0].length;
				let singleArray = new Array(rows * columns);
				for (let r = 0; r < rows; r++)
					for (let c = 0; c < columns; c++)
						singleArray[r * columns + c] = doubleArray[r][c];
				return new Matrix(rows, columns, singleArray);
			}
			Object.freeze(matrix);
			dyplot.matrix = matrix;



			function vector (...values) {
				values = Matrix.spread(values);
				return new Matrix(values.length, 1, values);
			}
			Object.freeze(vector);
			dyplot.vector = vector;



			function __splitValues__ (valueArr) {
				valueArr = Matrix.spread(valueArr);
				for (let i = 0; i < valueArr.length; i++) {
					let value = valueArr[i];
					if (value instanceof Matrix) {
						let matrix = value;
						valueArr.splice(i, 1);
						return [matrix, valueArr];
					}
				}
				throw "Could Not Find Matrix";
			}




			function mult (...values) {
				const [matrix, valuesM] = __splitValues__(values);
				return matrix.matmul(valuesM);
			}
			Object.freeze(mult);
			dyplot.mult = mult;





			function multiply (...values) {
				const [matrix, valuesM] = __splitValues__(values);
				return matrix.multiply(valuesM);
			}
			Object.freeze(multiply);
			dyplot.multiply = multiply;





			function add (...values) {
				const [matrix, valuesM] = __splitValues__(values);
				return matrix.add(valuesM);
			}
			Object.freeze(add);
			dyplot.add = add;





			function magnitude (matrix, axis=0) {
				if (axis === 0) {
					let output = new Matrix(1, matrix.columns);
					for (let c = 0; c < matrix.columns; c++) {
						let sum = 0;
						for (let r = 0; r < matrix.rows; r++)
							sum += matrix.get(r, c);
						output.set(Math.sqrt(sum), 1, c);
					}
					return output;
				} else {
					let output = new Matrix(matrix.rows, 1);
					for (let r = 0; r < matrix.rows; r++) {
						let sum = 0;
						for (let c = 0; r < matrix.columns; c++);
							sum += matrix.get(r, c);
						output.set(Math.sqrt(sum), r, 1);
					}
					return output;
				}
			}
			Object.freeze(magnitude);
			dyplot.magnitude = magnitude;





			function normalize (matrix, axis=0) {
				let output = new Matrix(matrix.rows, matrix.columns) ;
				let mags = magnitude(matrix, axis) ;
				if (axis === 0) {
					for (let r = 0; r < matrix.rows; r++)
						for (let c = 0; c < matrix.columns; c++)
							output.set(matrix.get(r, c) / mags.get(1, c)) ;
				} else {
					for (let r = 0; r < matrix.rows; r++)
						for (let c = 0; c < matrix.columns; c++)
							output.set(matrix.get(r, c) / mags.get(r, 1)) ;
				}
				return output ;
			}
			Object.freeze(normalize);
			dyplot.normalize = normalize;





			function create3DR (theta, axis) {
				// axis = normalize(axis);
				let ux = axis[0];
				let uy = axis[1];
				let uz = axis[2];
				let cos = Math.cos(theta);
				let sin = Math.sin(theta);
				return new Matrix(4, 4,
					cos + ux ** 2 * (1 - cos),   ux * uy * (1 - cos) - uz * sin,   ux * uz * (1 - cos) + uy * sin, 0,
					uy * ux * (1 - cos) + uz * sin,   cos + uy ** 2 * (1 - cos),   uy * uz * (1 - cos) - ux * sin, 0,
					uz * ux * (1 - cos) - uy * sin,   uz * uy * (1 - cos) + ux * sin,   cos + uz ** 2 * (1-cos),   0,
					0,								  0,													  0,   1
				);
			}
			Object.freeze(create3DR);
			dyplot.create3DR = create3DR;





			function createEulerR (pitch, yaw, roll) {
				let pitchM = create3DR (pitch, [1, 0, 0]);
				let yawM = create3DR (yaw, [0, 1, 0]);
				let rollM = create3DR (roll, [0, 0, 1]);
				return mult(rollM, yawM, pitchM);			
			}
			Object.freeze(createEulerR);
			dyplot.createEulerR = createEulerR;





			function create2DR (theta) {
				let cos = Math.cos(theta);
				let sin = Math.sin(theta);

				return new Matrix(3, 3, 
					cos, -sin, 0,
					sin, cos,  0,
					0,	   0,  1);
			}
			Object.freeze(create2DR);
			dyplot.create2DR = create2DR;





			function createD (...entries) {
				entries = Matrix.spread(entries);
				let size = entries.length;
				let output = new Matrix(size, size);
				for(let i = 0; i < size; i++)
					output.set(entries[i], i, i);
				return output;
			}
			Object.freeze(createD);
			dyplot.createD = createD;





			function createI (size) {
				let output = new Matrix(size, size);
				for (let i = 0; i < size; i ++)
					output.set(1, i, i);
				return output;
			}
			Object.freeze(createI);
			dyplot.createI = createI;




			function createT (...entries) {
				entries = Matrix.spread(entries);
				let size = entries.length;

				let output = createI(size + 1);
				for(let i = 0; i < size; i++)
					output.set(entries[i], i, size);
				return output;
			}
			Object.freeze(createT);
			dyplot.createT = createT;





			function __createPers__ (fov, near, far) {
				let s = 1 / Math.tan(fov/2)
				let c1 = - (far + near) / (far - near)
				let c2 = - 2 * far * near / (far - near)
				return new Matrix(4, 4,
						s, 0,  0,  0,
						0, s,  0,  0,
						0, 0, c1, c2,
						0, 0, -1,  0, 
					);
			}





			function __createOrtho__ (left, top, right, bottom, near, far) {
				let xs = right - left
				let xa = right + left
				let ys = top - bottom
				let ya = top + bottom
				let zs = far - near
				let za = far + near
				return new Matrix(4, 4,
						2/xs,    0,     0,  -xa/xs,
						0,    2/ys,     0,  -ya/ys,
						0,       0, -2/zs,  -za/zs,
						0,       0,     0,       1, 
					);
			}




			function __createOffsetMatrix__ (width, height) {
				return new Matrix(3, 3, 
					 1,  0, width / 2 , 
					 0,  - 1, height / 2 , 
					 0,  0,   1);
			}




			function __createInverseOffsetMatrix__(width, height) {
				return new Matrix(3, 3, 
					 1,  0, - width / 2 , 
					 0,  - 1, height / 2 , 
					 0,  0,   1);	
			}




			class Console {
				static __staticDeclarations__() {
					Console.__maxEntries__ = 100;
				}

				static print(msg, color="black") {
					if (msg === null) {
						msg = "null";
					} else if (msg === undefined) {
						msg = "undefined";
					} else {
						msg = msg.toString();
					}

					let console = document.getElementById("console");
					let childAmt = console.childElementCount;
					if (childAmt >= Console.__maxEntries__) {
						let descendents = console.getElementsByTagName('*');
						for (let i of range(childAmt-Console.__maxEntries__+1))
							console.removeChild(descendents[i]);
					}
					let elem = document.createElement("LI"); 
					elem.setAttribute("class", "list-group-item console-output");
					elem.setAttribute("style", "color: " + color + ";");
					elem.innerText = msg;
					console.appendChild(elem);
				}

				static clear() {
					let console = document.getElementById("console");
					console.innerHTML = "";
				}
			}
			Console.__staticDeclarations__();
			Object.freeze(Console);
			dyplot.Console = Console;



			class __MouseHandler__ {
				constructor(checkInBounds=null, onMove=null, onDown=null, onUp=null) {
					if ( checkInBounds !== null )
						this.checkInBounds = checkInBounds;
					if ( onMove !== null )
						this.onMove = onMove;
					if ( onUp !== null )
						this.onUp = onUp;
					if ( onDown !== null )
						this.onDown = onDown;
				}
				checkInBounds(x, y) {}
				onMove(x, y){}
				onUp(x, y){}
				onDown(x, y){}
			}




			class CanvasMouseHandler {
				constructor(canvas, defaultMoveHandler, scrollHandler) {
					this.canvas = canvas;

					this.mouseHandlerList = new LinkedList();
					this.defaultMoveHandler = defaultMoveHandler;
					
					this.mouseDown = false;
					this.selectedHandler = defaultMoveHandler;

					let obj = this;

					canvas.addEventListener("mousemove", function (e) {
			            let rect = canvas.getBoundingClientRect();
			            obj.move(e.clientX - rect.left, e.clientY - rect.top);
			        }, false);
			        canvas.addEventListener("mousedown", function (e) {
			            let rect = canvas.getBoundingClientRect();
			            obj.down(e.clientX - rect.left, e.clientY - rect.top);
			        }, false);
			        canvas.addEventListener("mouseup", function (e) {
			            let rect = canvas.getBoundingClientRect();
			            obj.up(e.clientX - rect.left, e.clientY - rect.top);
			        }, false);
			        canvas.addEventListener("mouseout", function (e) {
			            let rect = canvas.getBoundingClientRect();
			            obj.up(e.clientX - rect.left, e.clientY - rect.top);
			        }, false);
			        canvas.addEventListener("wheel", function (e) {
			            let rect = canvas.getBoundingClientRect();
			            scrollHandler(e.clientX - rect.left, e.clientY - rect.top, e.deltaY);
			        }, false);
				}

				get mouseHandlers() {
					return this.mouseHandlerList;
				}

				move (x, y) {
					if (this.mouseDown)
						this.selectedHandler.onMove(x, y);	
				}

				down (x, y) {
					this.mouseDown = true;
					for (let m_obj of this.mouseHandlerList) {
						if (m_obj.checkInBounds(x, y)) {
							this.selectedHandler = m_obj;
							m_obj.onDown(x, y);
							return;
						}
					}
					this.selectedHandler = this.defaultMoveHandler;
					this.defaultMoveHandler.onDown(x, y);
				}

				up (x, y) {
					if (this.mouseDown)
						this.selectedHandler.onUp(x, y);
					this.mouseDown = false;

				}
			}

			class Controls {
				static get(key) {
					return Control.allControls[key];
				}
				static has(key) {
					return key in Control.allControls;
				}
			} 
			Object.freeze(Controls);
			dyplot.Controls = Controls;



			class Control extends __MouseHandler__ {
				static __staticDeclarations__() {
					Control.CONTROL_RADIUS = 10;
					Control.allControls = {};
					Control.plottableControls = new LinkedList();
					Control.plottableControlsSet = {}; 
				}


				static __resetControls() {
					Control.allControls = {};
					Control.plottableControls.clear();
					Control.plottableControlsSet = {};				
					__CanvasGraph__.mouseHandler.mouseHandlerList.clear();
				}

				static __addControl(key, content, plottable=false) {
					if (plottable) {
						let [pointMatrix, figure, args] = content;
						if ( !(key in Control.allControls) ) {
							let control = new Control(pointMatrix, figure, args);
							Control.plottableControls.add(control);
							Control.plottableControlsSet[key] = control; 
							__CanvasGraph__.mouseHandler.mouseHandlerList.add(control);
							Control.allControls[key] = control.pointList;
						} else {
							let control = Control.plottableControlsSet[key];
							control.figure = figure;
							control.args = args;
						}
					} else {
						Control.allControls[key] = content;
					}
				}

				static __plotControls(graphTransform) {
					for (let control of Control.plottableControls) {
						let [pointMatrix, figure, args] = control.contents;
						let text = args["text"];
						if (text !== null && text !== undefined) {
							let textOrder = args["textOrder"];
							if (textOrder === "front") {
								__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);
								__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
							} else if (textOrder === "back") {
								__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
								__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);	
							} else {
								__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);
							}
						} else {
							__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);
						}
					}
				}

				static __toPointList(pointMatrix) {
					let n = pointMatrix.columns;
					let x_list = new Array(n);
					let y_list = new Array(n);
					for (let i of range(n)) {
						x_list[i] = pointMatrix.get(0, i);
						y_list[i] = pointMatrix.get(1, i);
					}
					return [x_list, y_list];
				}

				get pointMatrix () {
					return matrix(this.pointList).hv;
				}

				constructor (pointMatrix, figure, args) {
					super();
					this.pointList = Control.__toPointList(pointMatrix);
					this.figure = figure;
					this.args = args;
					this.selectedPoint = -1;
				}

				getTransformedPoints(x, y) {
					let touchP = vector(x, y, 1);
					let graphTransform = __CanvasGraph__.getInverseTransform();

					touchP = mult(graphTransform, touchP); 
					touchP = mult(this.figure.inverseTransform, touchP);
					x = touchP.get(0, 0);
					y = touchP.get(1, 0);
					return [x, y];
				}

				checkInBounds (x, y) {
					let radius;
					if (this.args.pointResize) {
						radius = this.args.pointRadius * __CanvasGraph__.zoomY;
					} else {
						radius = this.args.pointRadius;
					}

					let [rad_x, rad_y] = this.getTransformedPoints(radius+x, y);
					[x, y] = this.getTransformedPoints(x, y);

					let x_diff = rad_x - x;
					let y_diff = rad_y - y;

					let sqrRad = x_diff * x_diff + y_diff * y_diff;
					
					for (let c of range(this.pointList[0].length)) {
						let x_c = this.pointList[0][c];
						let y_c = this.pointList[1][c];
						x_diff = x - x_c;
						y_diff = y - y_c; 
						let distance = x_diff * x_diff + y_diff * y_diff;
						if (distance <= sqrRad) {
							this.selectedPoint = c;
							return true;	
						}
					}
					return false;
				}

				onMove(x, y) {
					[x, y] = this.getTransformedPoints(x, y);
					this.pointList[0][this.selectedPoint] = x;
					this.pointList[1][this.selectedPoint] = y;
					__CanvasGraph__.update();
				}

				get contents() {
					return [this.pointMatrix, this.figure, this.args];
				}
			}
			Control.__staticDeclarations__();
			DyPlot_Private.Control = Control;
			





			class __CanvasGraph__ {
				static __staticDeclarations__() {
					__CanvasGraph__.UPDATE_WAIT_TIME = 50;

					__CanvasGraph__.canvas = null;
					__CanvasGraph__.graph2D = null;
					__CanvasGraph__.mouseHandler = null;

					__CanvasGraph__.zoomX  =  0;
					__CanvasGraph__.zoomY  =  0;
					__CanvasGraph__.scrollSensitivity  =  .5;
					__CanvasGraph__.correctionScale = 1;
					__CanvasGraph__.xOffset = 0;
					__CanvasGraph__.yOffset = 0;
					__CanvasGraph__.offsetMatrix = new Matrix(3, 3);
					__CanvasGraph__.scaleMatrix  = new Matrix(3, 3);
					__CanvasGraph__.transMatrix  = new Matrix(3, 3);
					__CanvasGraph__.inverseOffsetMatrix = new Matrix(3, 3);
					__CanvasGraph__.inverseScaleMatrix  = new Matrix(3, 3);
					__CanvasGraph__.inverseTransMatrix  = new Matrix(3, 3);
					
					__CanvasGraph__.pointsAtHome = 10;
					__CanvasGraph__.zoomHomeValues = [1, 1];
					
					__CanvasGraph__.onUpdate = null;
					
					__CanvasGraph__.renderTriggered = false;
					__CanvasGraph__.updateTriggered = false;

					__CanvasGraph__._isInit = false;
					__CanvasGraph__.renderBuffer = new LinkedList();
					__CanvasGraph__.setupRenderBuffer = new LinkedList();

					__CanvasGraph__.renderBackTextBuffer = new LinkedList();
					__CanvasGraph__.setupBackTextRenderBuffer = new LinkedList();

					__CanvasGraph__.renderFrontTextBuffer = new LinkedList();
					__CanvasGraph__.setupFrontTextRenderBuffer = new LinkedList();

					__CanvasGraph__.useSetupBuffer = false;
				}

				static clearRenderBuffer() {
					__CanvasGraph__.renderBuffer.clear();
					__CanvasGraph__.renderBackTextBuffer.clear();
					__CanvasGraph__.renderFrontTextBuffer.clear();
				}

				static clearSetupBuffer() {
					__CanvasGraph__.setupRenderBuffer.clear();
					__CanvasGraph__.setupBackTextRenderBuffer.clear();
					__CanvasGraph__.setupFrontTextRenderBuffer.clear();
				}

				// static clearRender


				static zoomHome() {
					__CanvasGraph__.setZoom(__CanvasGraph__.zoomHomeValues[0], __CanvasGraph__.zoomHomeValues[1]);
					__CanvasGraph__.setTranslate(0, 0);
					__CanvasGraph__.render();
				}

				static init(onUpdate = null, onSetup = null) {
					if (__CanvasGraph__._isInit)
						throw new Error("Canvas graph is already initialized");
					__CanvasGraph__._isInit = true;

					__CanvasGraph__.canvas  = document.getElementById("graph");
					__CanvasGraph__.graph2D = __CanvasGraph__.canvas.getContext("2d");

					__CanvasGraph__.mouseHandler = __CanvasGraph__.__makeDefaultMouseHandler(__CanvasGraph__.canvas); 
					Control.__resetControls();

					__CanvasGraph__.setOnUpdate(onUpdate);
					__CanvasGraph__.zoomHome();
					__CanvasGraph__.updateCanvasSize();

					if (onSetup !== null)
						onSetup();
					__CanvasGraph__._update();
					__CanvasGraph__._render();
					__CanvasGraph__.updateTriggered = false;
					__CanvasGraph__.renderTriggered = false;


					let loop = async function () {
						while (true) {
							__CanvasGraph__.updateCanvasSize();	  
							__CanvasGraph__._update();
							__CanvasGraph__._render();
							await __Utils__.sleep(__CanvasGraph__.UPDATE_WAIT_TIME);
						}
					};
					loop();
				}

				static __makeDefaultMouseHandler(canvas) {
					let pi = {x:0, y:0};
					
					let onMove = (x, y) => {
						let diffX = x - pi.x;
						let diffY = y - pi.y;
						let newX  = __CanvasGraph__.xOffset + diffX / __CanvasGraph__.zoomX / __CanvasGraph__.correctionScale;
						let newY  = __CanvasGraph__.yOffset - diffY / __CanvasGraph__.zoomY / __CanvasGraph__.correctionScale;
						__CanvasGraph__.setTranslate(newX, newY);
						pi.x = x;
						pi.y = y;
					};
					
					let onDown = (x, y) => {
						pi.x = x;
						pi.y = y;
					};
					
					let doNothing = (x, y) => {};
					
					let defaultMouseHandler =  new __MouseHandler__(doNothing, onMove, onDown, doNothing);

					let onScroll = (x, y, amt) => {

						let zoomX = __CanvasGraph__.zoomX;
						let zoomY = __CanvasGraph__.zoomY;
						let factor = __CanvasGraph__.scrollSensitivity;

						let zoomChange = 1 + (Math.abs(amt) * factor) / 100;
						if ( amt < 0 ) {
							zoomChange = 1 / zoomChange;
						}

						let xOffset = __CanvasGraph__.xOffset;
						let yOffset = __CanvasGraph__.yOffset;

						let location = vector(x, y, 1);
						let transform = __CanvasGraph__.getInverseTransform();
						let initialPoint = mult(transform, location);

						__CanvasGraph__.setZoom(zoomX*zoomChange, zoomY*zoomChange);
						
						location = vector(x, y, 1);
						transform = __CanvasGraph__.getInverseTransform();
						let finalPoint = mult(transform, location);

						
						let deltaX = finalPoint.get(0, 0) - initialPoint.get(0, 0);
						let deltaY = finalPoint.get(1, 0) - initialPoint.get(1, 0);

						__CanvasGraph__.setTranslate(xOffset + deltaX, yOffset + deltaY);
					};
					return new CanvasMouseHandler(canvas, defaultMouseHandler, onScroll);
				}

				static setOnUpdate(onUpdate) {
					if (onUpdate === null)
						onUpdate = () => {};
					else 
						__CanvasGraph__.onUpdate = onUpdate;
					__CanvasGraph__.update();
				}

				static update() {				
					__CanvasGraph__.updateTriggered = true;
					__CanvasGraph__.renderTriggered = true;
				}

				static render() {
					__CanvasGraph__.renderTriggered = true;				
				}

				static _update() {
					if(!__CanvasGraph__.updateTriggered)
						return;
					__CanvasGraph__.updateTriggered = false;
					__CanvasGraph__.clearRenderBuffer();
					__CanvasGraph__.onUpdate();
				}

				static _render() {
					if(!__CanvasGraph__.renderTriggered)
						return;
					__CanvasGraph__.renderTriggered = false;
					__CanvasGraph__.clearCanvas();
					try {
						__CanvasGraph__.plotStoredPoints();
					} catch (e) {
						Console.print("Arguments for a figure or plot are invalid:");
						__printError__(e);
					}
				}

				static clearCanvas() {
					__CanvasGraph__.graph2D.clearRect(0, 0, __CanvasGraph__.canvas.width, __CanvasGraph__.canvas.height);
				}

				static setTranslate(newX, newY) {
					__CanvasGraph__.xOffset = newX;
					__CanvasGraph__.yOffset = newY;
					__CanvasGraph__.transMatrix = createT(newX, newY);
					__CanvasGraph__.inverseTransMatrix = createT(-newX, -newY);
					__CanvasGraph__.render();
				}

				static setZoom(newZoomX, newZoomY) {
					__CanvasGraph__.zoomX = newZoomX;
					__CanvasGraph__.zoomY = newZoomY;
					__CanvasGraph__.scaleMatrix = createD(__CanvasGraph__.zoomX, __CanvasGraph__.zoomY, 1);
					__CanvasGraph__.inverseScaleMatrix = createD(1/__CanvasGraph__.zoomX, 1/__CanvasGraph__.zoomY, 1);
					__CanvasGraph__.render();
				}

				static updateCanvasSize() {
					let canvas = __CanvasGraph__.canvas;
					let rect = __CanvasGraph__.canvas.getBoundingClientRect();

					let height = window.innerHeight - rect.top;
					let width = rect.right - rect.left;

					if (Math.floor(Math.abs(canvas.width-width)) === 0 && Math.floor(Math.abs(canvas.height - height)) === 0)
						return;
					let smallerLength = width < height ? width : height ;

					let homePoints = __CanvasGraph__.pointsAtHome;

					__CanvasGraph__.correctionScale = smallerLength / homePoints ;
					canvas.width = width;
					canvas.height = height;
					
					let scaleHomeMat = createD(__CanvasGraph__.correctionScale, __CanvasGraph__.correctionScale, 1);
					let offsetMatrix = __createOffsetMatrix__(width, height);
					__CanvasGraph__.offsetMatrix = mult(offsetMatrix, scaleHomeMat);
					
					let inverseScaleHomeMat = createD(1/__CanvasGraph__.correctionScale, 1/__CanvasGraph__.correctionScale, 1);
					let inverseOffsetMatrix = __createInverseOffsetMatrix__(width, height);
					__CanvasGraph__.inverseOffsetMatrix = mult(inverseScaleHomeMat, inverseOffsetMatrix);

					__CanvasGraph__.render();
				}

				static getTransform() {
					return mult(__CanvasGraph__.offsetMatrix, __CanvasGraph__.scaleMatrix, __CanvasGraph__.transMatrix);
				}

				static getInverseTransform() {
					return mult(__CanvasGraph__.inverseTransMatrix, __CanvasGraph__.inverseScaleMatrix, __CanvasGraph__.inverseOffsetMatrix);
				}

				static setColor(fill, stroke=fill) {
					let graph2D = __CanvasGraph__.graph2D;
					graph2D.fillStyle = fill;
					graph2D.strokeStyle = stroke;
				}

				static plotText(text, x, y, size) {
					let graph2D = __CanvasGraph__.graph2D;
					graph2D.font = "" + size + "px Arial";
					graph2D.fillText(text, x, y);
				}

				static plotPoint(x, y, radius=5) {
					let graph2D = __CanvasGraph__.graph2D;
					graph2D.beginPath();
					graph2D.arc(x, y, radius, 0, 2 * Math.PI);
					graph2D.closePath();
					graph2D.fill();
					graph2D.stroke();
				}

				static getPointArgs(args, defaultArgs={}) { 
					let defaultRadius = ("link" in args) ? 10 : 5;
					let pointArgs = {
						link:null,
						showPoints:true,
						pointColor:"black",
						pointRadius: defaultRadius,
						pointResize: false,
						showLines:false,
						closePath : false,
						lineColor:"black",
						lineDash:[],
						lineWidth:1,
						text: null,
						textColor: "black",
						textOrder: "front",
						textSize: 30,
						textResize: true,
						textAlign: "left",
						textOffset: [0, 0]
					}

					for (let key in defaultArgs) {
					    if (pointArgs.hasOwnProperty(key))
							pointArgs[key] = defaultArgs[key];
						else
							throw new Error('The arg "' + key + '" is not defined.');
					}

					for (let key in args) {
					    if (pointArgs.hasOwnProperty(key))
							pointArgs[key] = args[key];
						else
							throw new Error('The arg "' + key + '" is not defined.');
					}

					return pointArgs;
				}

				static plotPoints(pointMatrix, pointArgs, figureTransform, transform=__CanvasGraph__.getTransform()) {

					pointMatrix = mult(figureTransform, pointMatrix);
					pointMatrix = mult(transform, pointMatrix);


					if (pointArgs.showLines && pointMatrix.columns > 1) {
						__CanvasGraph__.setColor(pointArgs.lineColor);

						let graph2D = __CanvasGraph__.graph2D;
						graph2D.setLineDash(pointArgs.lineDash);
						graph2D.lineWidth = pointArgs.lineWidth;
						graph2D.beginPath();
						graph2D.moveTo(pointMatrix.get(0, 0),pointMatrix.get(1, 0));
						for (let i = 1; i < pointMatrix.columns; i++)
							graph2D.lineTo(pointMatrix.get(0, i),pointMatrix.get(1, i));
						if (pointArgs.closePath) 
							graph2D.closePath();
						graph2D.stroke();
						graph2D.setLineDash([]);
						graph2D.lineWidth = 1;
					}

					if (pointArgs.showPoints) {
						__CanvasGraph__.setColor(pointArgs.pointColor);
						let radius;
						if (pointArgs.pointResize) {
							radius = pointArgs.pointRadius * __CanvasGraph__.zoomY;
						} else {
							radius = pointArgs.pointRadius;
						}
						for (let i = 0; i < pointMatrix.columns; i++)
							__CanvasGraph__.plotPoint(pointMatrix.get(0, i), pointMatrix.get(1, i), radius);
					}
				}

				static plotTextPoints(pointMatrix, pointArgs, figureTransform, transform=__CanvasGraph__.getTransform()) {

					let original = pointMatrix;
					pointMatrix = mult(figureTransform, pointMatrix);
					pointMatrix = mult(transform, pointMatrix);

					__CanvasGraph__.setColor(pointArgs.textColor);
					let size = 1;
					if (pointArgs.textResize) {
						size = pointArgs.textSize * __CanvasGraph__.zoomY;
					} else {
						size = pointArgs.textSize;
					}

					let textOffset = pointArgs.textOffset;
					let x_off = 0;
					let y_off = 0;
					if (__CanvasGraph__.correctionScale !== 0) {
						x_off = textOffset[0] * __CanvasGraph__.zoomX * __CanvasGraph__.correctionScale;
						y_off = textOffset[1] * __CanvasGraph__.zoomY * __CanvasGraph__.correctionScale;
					}

					__CanvasGraph__.graph2D.textAlign = pointArgs.textAlign;
					let text = pointArgs.text;
					if (typeof text === "string") {
						for (let i = 0; i < pointMatrix.columns; i++)
							__CanvasGraph__.plotText(text, pointMatrix.get(0, i) + x_off, pointMatrix.get(1, i) - y_off, size);
					} else {
						for (let i = 0; i < pointMatrix.columns; i++) {
							let x = original.get(0, i);
							let y = original.get(1, i);
							let msg = text(x, y);
							__CanvasGraph__.plotText(msg, pointMatrix.get(0, i) + x_off, pointMatrix.get(1, i) - y_off, size);
						}
					}
				}

				static plotStoredPoints() {
					let graphTransform = __CanvasGraph__.getTransform();

					for (let item of __CanvasGraph__.setupBackTextRenderBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					for (let item of __CanvasGraph__.renderBackTextBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					for (let item of __CanvasGraph__.setupRenderBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					for (let item of __CanvasGraph__.renderBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					for (let item of __CanvasGraph__.setupFrontTextRenderBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					for (let item of __CanvasGraph__.renderFrontTextBuffer) {
						let [pointMatrix, figure, args] = item;
						__CanvasGraph__.plotTextPoints(pointMatrix, args, figure.transform, graphTransform);
					}
					Control.__plotControls(graphTransform);
				}

				static storePlottedPoints(pointMatrix, figure, args) {
					
					let link = args["link"];
					let content = [pointMatrix, figure, args];
					if(link !== null) {
						Control.__addControl(link, content, true);
					} else {
						if (__CanvasGraph__.useSetupBuffer) {
							let text = args["text"];
							__CanvasGraph__.setupRenderBuffer.enqueue(content);
							if (text !== null && text !== undefined) {
								let textOrder = args["textOrder"];
								if (textOrder === "front") {
									__CanvasGraph__.setupFrontTextRenderBuffer.enqueue(content);
								} else if (textOrder === "back") {
									__CanvasGraph__.setupBackTextRenderBuffer.enqueue(content);
								} else {
									throw new Error("textOrder arg must be either \"front\" or \"back\"");
								}
							}
						} else {
							let text = args["text"];
							__CanvasGraph__.renderBuffer.enqueue(content);
							if (text !== null && text !== undefined) {
								let textOrder = args["textOrder"];
								if (textOrder === "front") {
									__CanvasGraph__.renderFrontTextBuffer.enqueue(content);
								} else if (textOrder === "back") {
									__CanvasGraph__.renderBackTextBuffer.enqueue(content);
								} else {
									throw new Error("textOrder arg must be either \"front\" or \"back\"");
								}
							}	
						}
					}
				}
			}
			__CanvasGraph__.__staticDeclarations__();
			DyPlot_Private.__CanvasGraph__ = __CanvasGraph__;

			class Figure {
				
				static get2DPointMatrix(xArr, yArr) {
					let output = null;
					if (typeof (xArr) === "number")
						xArr = [xArr];
					if (typeof (yArr) === "number")
						yArr = [yArr];

					if (yArr === null)
						output = matrix(xArr);
					else
						output = matrix([xArr, yArr]);
					
					let rows = output.rows;
					if (rows >= 3) {
						let cols = output.columns;
						output = output.subMat(range(2), range(cols));
					}
					output = output.hv;
					return output;
				}

				static get3DPointMatrix(xArr, yArr, zArr) {
					let output = null;
					if (typeof (xArr) === "number")
						xArr = [xArr];
					if (typeof (yArr) === "number")
						yArr = [yArr];
					if (typeof (zArr) === "number")
						zArr = [zArr];
					
					if (yArr === null)
						output = matrix(xArr);
					else
						output = matrix([xArr, yArr, zArr]);

					let rows = output.rows;
					if (rows >= 4) {
						let cols = output.columns;
						output = output.subMat(range(3), range(cols));
					}
					output = output.hv;
					return output;
				}

				constructor(args={}) {
					this.args = {
						t:[0, 0],
						s:[1, 1],
						r: 0,
						or:[Math.PI/4, -Math.PI/4, -Math.PI/6],
						ct:[-1,-1, -1],
						is3D:false,
						pers:true,
						box:[-1, 1, 1, -1, -1, 1],
						fov:Math.PI/2,
					};
					this._setFigureArgs(args);
				}

				_setFigureArgs(args) {
					for (let key in args) {
					    if (this.args.hasOwnProperty(key))
							this.args[key] = args[key];
						else 
							throw new Error('The arg "' + key + '" is not defined.');
					}
					if (this.args.is3D) {
						let projection = null;
						let box = this.args.box;
						if (this.args.pers)
							projection = __createPers__ (this.args.fov, box[4], box[5]);
						else
							projection = __createOrtho__ (box[0], box[1], box[2], box[3], box[4], box[5]);
						let s = this.args.s;
						let scale = createD(s[0], s[1], 1, 1);
						let t = this.args.t;
						let translate = createT(t[0], t[1], 0);
						let r = this.args.r;
						let rotate = create2DR(r).h;

						let ct = this.args.ct;
						let cameraTranslate = createT(ct[0], ct[1], ct[2]);
						
						let or = this.args.or;
						let originRotate = createEulerR (or[0], or[1], or[2]);
						
						this.transform = mult(translate, rotate, scale, projection, cameraTranslate, originRotate);
					} else {
						let s = this.args.s;
						let scale = createD(s[0], s[1], 1);
						let inverseScale = createD(1/s[0], 1/s[1], 1);
						let t = this.args.t;
						let translate = createT(t[0], t[1]);
						let inverseTranslate = createT(-t[0], -t[1]);
						let r = this.args.r;
						let rotate = create2DR(r);
						let inverseRotate = create2DR(-r);

						this.transform = mult(translate, rotate, scale);
						this.inverseTransform = mult(inverseScale, inverseRotate, inverseTranslate);
					}
					__CanvasGraph__.render();
				}

				plotXY(x, y=null, args={}) {
					if (this.args.is3D)
						throw new Error("Cannot plot 2D points on a 3D figure");

					let pointMatrix = Figure.get2DPointMatrix(x, y);
					let pointArgs = __CanvasGraph__.getPointArgs(args);
					__CanvasGraph__.storePlottedPoints(pointMatrix, this, pointArgs);
				}

				plotXYZ(x, y=null, z=null, args={}) {
					if (!this.args.is3D)
						throw new Error("Cannot plot 3D points on a 2D figure");
					if("link" in args)
						throw new Error("Cannot link a control to 3D points");
					let pointMatrix = Figure.get3DPointMatrix(x, y, z);
					let pointArgs = __CanvasGraph__.getPointArgs(args);
					__CanvasGraph__.storePlottedPoints(pointMatrix, this, pointArgs);
				}

				plotAxis(size=1, showNeg=true) {
					let start = showNeg? -size : 0;
					if (showNeg)
					if (this.args.is3D) {
						this.plotXYZ([start, size], [0, 0], [0, 0], {showPoints:false, showLines:true, lineColor: "red"});
						this.plotXYZ([0, 0], [start, size], [0, 0], {showPoints:false, showLines:true, lineColor: "green"});
						this.plotXYZ([0, 0], [0, 0], [start, size], {showPoints:false, showLines:true, lineColor: "blue"});
					} else {
						this.plotXY([start, size], [0, 0], {showPoints:false, showLines:true, lineColor: "red"});
						this.plotXY([0, 0], [start, size], {showPoints:false, showLines:true, lineColor: "green"});
					}
				}

				plotText(displayText, x, y=null, args={}) {
					if (this.args.is3D)
						throw new Error("Cannot plot 2D text on a 3D figure");

					let pointMatrix = Figure.get2DPointMatrix(x, y);
					let pointArgs = __CanvasGraph__.getPointArgs(args, {showPoints:false, text: displayText});
					__CanvasGraph__.storePlottedPoints(pointMatrix, this, pointArgs);
				}

			}
			Object.freeze(Figure);
			dyplot.Figure = Figure;



			$('.toast').toast({
	          delay: 3000
	        });

			function __alert__(msgTitle, msgBody) {
				let title = document.getElementById("alert_title"); 
				let body = document.getElementById("alert_body");
				title.innerText = msgTitle;
				body.innerText = msgBody;
				$('.toast').css("width", "300px");
		        $('.toast').on("hidden.bs.toast", () => {
		          $('this').width = 0;
		        });
				$('.toast').toast('show');
			}
			DyPlot_Private.__alert__ = __alert__;


			DyPlot_Private.__zoomIn__ = function () {
				__CanvasGraph__.setZoom(__CanvasGraph__.zoomX * 2, __CanvasGraph__.zoomY * 2);
			}

			DyPlot_Private.__zoomHome__ = function () {
				__CanvasGraph__.zoomHome();
			}

			DyPlot_Private.__zoomOut__ = function () {
				__CanvasGraph__.setZoom(__CanvasGraph__.zoomX * 1/2, __CanvasGraph__.zoomY * 1/2);
			}




			let __tabState__ = "User";
			DyPlot_Private.__switchToDeveloper__ = function () {
				if(__tabState__ === "User") {
					__tabState__ = "Dev";
				}
			}
			DyPlot_Private.__switchToUser__ = function () {
				if(__tabState__ === "Dev") {
					DyPlot_Private.__onSetup__();
					__alert__("Dynamic Web Plot", "Updated Plots");
					__tabState__ = "User";
				}
			}

			function __initEditors__ () {
				let setup_editor = ace.edit("setup-editor");
			    setup_editor.setTheme("ace/theme/monokai");
			    setup_editor.session.setMode("ace/mode/javascript");
			    setup_editor.resize();

			    let update_editor = ace.edit("update-editor");
				update_editor.setTheme("ace/theme/monokai");
			    update_editor.session.setMode("ace/mode/javascript");
			    update_editor.resize();
			}
			__initEditors__ ();

			function __escapeHtml__(unsafe) {
			    return unsafe
			         .replace(/&/g, "&amp;")
			         .replace(/</g, "&lt;")
			         .replace(/>/g, "&gt;")
			         .replace(/"/g, "&quot;")
			         .replace(/'/g, "&#039;");
			}
			
			function __readFile__(file) {
				return new Promise((resolve, reject) => {
					let reader = new FileReader();
					reader.onload = function(e) {
						resolve(e.target.result);
					};
					reader.onerror = reject;
					reader.readAsText(file);
				});
			}

			function __fileOpen__(e) {
				let file = e.target.files[0];
				if (!file)
					return;
				__load__(file);
			}

			async function __load__(file) {
				let contents;
				try {
					contents = await __readFile__(file);
					contents = JSON.parse(contents);
				} catch (err) {
					__alert__("Dynamic Web Plot", "Could not read file!");
					console.log(err);
					return;
				}
				try {
					let controls = contents["controls"];
					let setup_code =  contents["setup.js"];
					let update_code = contents["update.js"];

					let setup_editor = ace.edit("setup-editor");
					setup_editor.setValue(setup_code);

					let update_editor = ace.edit("update-editor");
					update_editor.setValue(update_code);

					Control.__resetControls();
					DyPlot_Private.__onSetup__();
					__CanvasGraph__._update();
					
					for (key in controls) {
						let value = Controls.get(key);
						let newValue = controls[key];
						value[0] = newValue[0];
						value[1] = newValue[1];
					}
					__CanvasGraph__.update();
					__alert__("Dynamic Web Plot", "Plot is loaded");
				} catch (err) {
					__alert__("Dynamic Web Plot", "Could not properly load file!");
					console.log(err);
					return;
				}
			}

			document.getElementById('file-open-form').addEventListener('change', __fileOpen__, false);
			
			// document.body.ondragover = function(e) {
			// 	e.preventDefault();
			// }

			// document.body.ondrop = function (e) {
			// 	const dT = new DataTransfer();
			// 	dT.items.add(evt.dataTransfer.files[0]);
			// 	let file = dT.files[0];
				
			// 	if (!file)
			// 		return;
			// 	__load__(file);
			// }

			// Save handler
			function __save__() {
				let setup_editor = ace.edit("setup-editor");
				let update_editor = ace.edit("update-editor");

				let setup_code = setup_editor.getValue();
				let update_code = update_editor.getValue();

				let toSave = {};
				toSave["controls"] = Control.allControls; 
				toSave["setup.js"] = setup_code;
				toSave["update.js"] = update_code;

				toSave = JSON.stringify(toSave);

				__download__(toSave, "Untitled-dyplot", 'application/json;charset=utf-8');
				__alert__("Dynamic Web Plot", "Saved");			
			}
			DyPlot_Private.__save__ = __save__;

			function __download__(data, filename, type) {
				let file = new Blob([data], {type: type});
				if (window.navigator.msSaveOrOpenBlob) // IE10+
					window.navigator.msSaveOrOpenBlob(file, filename);
				else { // Others
					let a = document.createElement("a"),
					url = URL.createObjectURL(file);
					a.href = url;
					a.download = filename;
					document.body.appendChild(a);
					a.click();
					setTimeout(function() {
						document.body.removeChild(a);
						window.URL.revokeObjectURL(url);  
					}, 0); 
				}
			}
			DyPlot_Private.__download__ = __download__;


			document.addEventListener("keydown", function(e) {
				if ((window.navigator.platform.match("Mac") ? e.metaKey : e.ctrlKey)  && e.keyCode == 83) {
					e.preventDefault();
					DyPlot_Private.__save__();	
				}
			}, false);



			let __printError__ = function (e) {
				if (e === null || e === undefined) {
					Console.print(e.stack.toString(), "Unknown Error Occurred");	
				} else if (e.hasOwnProperty("stack") && e.stack !== undefined && e.stack !== null) {
					Console.print(e.stack.toString(), "red");
				} else {
					Console.print(e, "red");
				}
			}
			DyPlot_Private.__printError__ = __printError__;
		})(dyplot, DyPlot_Private, jQuery, undefined);
		


		let DyPlot_Mutable = {};
		// Define __update__ where scope is not under dyplot scope
		DyPlot_Mutable.__update__ = function () {};

		// Define __onSetup__ where scope is not under dyplot scope
		DyPlot_Private.__onSetup__ = function () {
			let setup_editor = ace.edit("setup-editor");
			let update_editor = ace.edit("update-editor");

			DyPlot_Mutable.setup_code = setup_editor.getValue();
			DyPlot_Mutable.update_code = update_editor.getValue();
			try {
				DyPlot_Private.__CanvasGraph__.clearSetupBuffer();
				DyPlot_Private.__CanvasGraph__.useSetupBuffer = true;
				(function () {
					let window   = undefined;
					let document = undefined;
					let XMLHttpRequest = undefined;
					let WebAssembly = undefined;
					let setTimeout = undefined;
					let print = undefined;
					let jQuery = undefined;
					let $        = undefined;
					let setup_editor = undefined;
					let update_editor = undefined;
					let DyPlot_Private = undefined;
					{
						eval(DyPlot_Mutable.setup_code);
						eval(
							"DyPlot_Mutable.__update__ = function () {"
								+ DyPlot_Mutable.update_code +
							"\n};"
						);
					}
				})();
				DyPlot_Private.__CanvasGraph__.useSetupBuffer = false;
			} catch (e) {
				DyPlot_Mutable.__update__ = function() {};
				DyPlot_Private.__printError__(e);
			}
			DyPlot_Private.__CanvasGraph__.update();	
		};
		
		// Define __onUpdate__ where scope does is not under dyplot scope
		DyPlot_Private.__onUpdate__ = function() {
			try {
				DyPlot_Mutable.__update__();		
			} catch (e) {
				DyPlot_Private.__printError__(e);
			}
		};

		// Init CanvasGraph
		DyPlot_Private.__CanvasGraph__.init(DyPlot_Private.__onUpdate__, DyPlot_Private.__onSetup__);

		// Make dyplot Immutable
		Object.freeze(dyplot);


	</script>
</html>